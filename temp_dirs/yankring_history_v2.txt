,V
http://www.vim.org/scripts/script.php?script_id=273,v
  g_timeout_add (200, (GSourceFunc) cb_print_position, pipeline);,V
Python,v
**/*.,v
/,v
GST_VALUE_HOLDS_DATE_TIME,v
/media/NEW VOLUME/Video Check List/xvid_mp3_ASP@l5_44KHz_CBR_stereo_222Kbps_720x480_537Kbps_23.98fps.avi,v
 * gcc -o tags tags.c `pkg-config --cflags --libs gstreamer-1.0` */,V
GST_BUFFER_SIZE,v
/* compile with: * gcc -o tags tags.c `pkg-config --cflags --libs gstreamer-1.0` */#include <gst/gst.h>static voidprint_one_tag (const GstTagList * list, const gchar * tag, gpointer user_data){  int i, num;  num = gst_tag_list_get_tag_size (list, tag);  for (i = 0; i < num; ++i) {    const GValue *val;    /* Note: when looking for specific tags, use the g_tag_list_get_xyz() API,     * we only use the GValue approach here because it is more generic */    val = gst_tag_list_get_value_index (list, tag, i);    if (G_VALUE_HOLDS_STRING (val)) {      g_print ("\t%20s : %s\n", tag, g_value_get_string (val));    } else if (G_VALUE_HOLDS_UINT (val)) {      g_print ("\t%20s : %u\n", tag, g_value_get_uint (val));    } else if (G_VALUE_HOLDS_DOUBLE (val)) {      g_print ("\t%20s : %g\n", tag, g_value_get_double (val));    } else if (G_VALUE_HOLDS_BOOLEAN (val)) {      g_print ("\t%20s : %s\n", tag,          (g_value_get_boolean (val)) ? "true" : "false");    } else if (GST_VALUE_HOLDS_BUFFER (val)) {      g_print ("\t%20s : buffer of size %u\n", tag,          GST_BUFFER_SIZE (gst_value_get_buffer (val)));    } else if (GST_VALUE_HOLDS_DATE (val)) {      g_print ("\t%20s : date (year=%u,...)\n", tag,          g_date_get_year (gst_value_get_date (val)));    } else {      g_print ("\t%20s : tag of type '%s'\n", tag, G_VALUE_TYPE_NAME (val));    }  }}static voidon_new_pad (GstElement * dec, GstPad * pad, GstElement * fakesink){  GstPad *sinkpad;  sinkpad = gst_element_get_static_pad (fakesink, "sink");  if (!gst_pad_is_linked (sinkpad)) {    if (gst_pad_link (pad, sinkpad) != GST_PAD_LINK_OK)      g_error ("Failed to link pads!");  }  gst_object_unref (sinkpad);}intmain (int argc, char ** argv){  GstElement *pipe, *dec, *sink;  GstMessage *msg;  gst_init (&argc, &argv);  if (argc < 2 || !gst_uri_is_valid (argv[1]))    g_error ("Usage: %s file:///path/to/file", argv[0]);  pipe = gst_pipeline_new ("pipeline");  dec = gst_element_factory_make ("uridecodebin", NULL);  g_object_set (dec, "uri", argv[1], NULL);  gst_bin_add (GST_BIN (pipe), dec);  sink = gst_element_factory_make ("fakesink", NULL);  gst_bin_add (GST_BIN (pipe), sink);  g_signal_connect (dec, "pad-added", G_CALLBACK (on_new_pad), sink);  gst_element_set_state (pipe, GST_STATE_PAUSED);  while (TRUE) {    GstTagList *tags = NULL;    msg = gst_bus_timed_pop_filtered (GST_ELEMENT_BUS (pipe),        GST_CLOCK_TIME_NONE,        GST_MESSAGE_ASYNC_DONE | GST_MESSAGE_TAG | GST_MESSAGE_ERROR);    if (GST_MESSAGE_TYPE (msg) != GST_MESSAGE_TAG) /* error or async_done */      break;    gst_message_parse_tag (msg, &tags);    g_print ("Got tags from element %s:\n", GST_OBJECT_NAME (msg->src));    gst_tag_list_foreach (tags, print_one_tag, NULL);    g_print ("\n");    gst_tag_list_unref (tags);    gst_message_unref (msg);  };  if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_ERROR)    g_error ("Got error");  gst_message_unref (msg);  gst_element_set_state (pipe, GST_STATE_NULL);  gst_object_unref (pipe);  return 0;},v
%E8%BD%AC%E5%8F%91%E5%BE%AE%E5%8D%9A,v
time_nanoseconds,,v
;,v
if (!gst_element_seek (pipeline, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,                         GST_SEEK_TYPE_SET, time_nanoseconds,                         GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE)) {    g_print ("Seek failed!\n");,v
{       ,v
8,v
gcc -Wall `pkg-config --cflags gstreamer-1.0` -g test4.c -o test4 `pkg-config gstreamer-1.0 --libs`,v
-,v
  if (gst_element_query_position (pipeline, GST_FORMAT_TIME, &pos)    && gst_element_query_duration (pipeline, GST_FORMAT_TIME, &len)) {    g_print ("Time: %" GST_TIME_FORMAT " / %" GST_TIME_FORMAT "\r",	     GST_TIME_ARGS (pos), GST_TIME_ARGS (len));,V
0,v
  g_main_loop_run (loop);,V
/* run pipeline */  g_timeout_add (200, (GSourceFunc) cb_print_position, pipeline);  g_main_loop_run (loop);,v
static gbooleancb_print_position (GstElement *pipeline){  gint64 pos, len;  if (gst_element_query_position (pipeline, GST_FORMAT_TIME, &pos)    && gst_element_query_duration (pipeline, GST_FORMAT_TIME, &len)) {    g_print ("Time: %" GST_TIME_FORMAT " / %" GST_TIME_FORMAT "\r",	     GST_TIME_ARGS (pos), GST_TIME_ARGS (len));  }  /* call me again */  return TRUE;},v
set nocompatible,V
set fileencodings=utf-8,chinese,latin-1,V
language messages zh_CN.utf-8,V
“解决consle输出乱码,V
source $VIMRUNTIME/menu.vim,V
source $VIMRUNTIME/delmenu.vim,V
“解决菜单乱码,V
endif,V
set fileencoding=utf-8,V
else,V
set fileencoding=chinese,V
if has(“win32″),V
set encoding=utf-8,V
"字体的设置set guifont=Bitstream_Vera_Sans_Mono:h9:cANSI "记住空格用下划线代替哦set gfw=幼圆:h10:cGB2312,v
set backspace=indent,eol,start whichwrap+=<,>,[,] "允许退格键的使用if(g:iswindows==1) "允许鼠标的使用    "防止linux终端下无法拷贝    if has('mouse')        set mouse=a    endif    au GUIEnter * simalt ~xendif,v
set backspace=indent,eol,start whichwrap+=<,>,[,] "????????if(g:iswindows==1) "???????    "??linux???????    if has('mouse')        set mouse=a    endif    au GUIEnter * simalt ~xendif"?????set guifont=Bitstream_Vera_Sans_Mono:h9:cANSI "???????????set gfw=??:h10:cGB2312,v
"不自动换行,v
"?????,v
if has("autocmd")    filetype plugin indent on "根据文件进行缩进    augroup vimrcEx        au!        autocmd FileType text setlocal textwidth=78        autocmd BufReadPost *                    \ if line("'\"") > 1 && line("'\"") <= line("$") |                    \ exe "normal! g`\"" |                    \ endif    augroup ENDelse    "智能缩进，相应的有cindent，官方说autoindent可以支持各种文件的缩进，但是效果会比只支持C/C++的cindent效果会差一点，但笔者并没有看出来    set autoindent " always set autoindenting on endif " has("autocmd"),v
if has("autocmd")    filetype plugin indent on "????????    augroup vimrcEx        au!        autocmd FileType text setlocal textwidth=78        autocmd BufReadPost *                    \ if line("'\"") > 1 && line("'\"") <= line("$") |                    \ exe "normal! g`\"" |                    \ endif    augroup ENDelse    "?????????cindent????autoindent?????????????????????C/C++?cindent????????????????    set autoindent " always set autoindenting on endif " has("autocmd"),v
set encoding=utf-8set fileencodings=utf-8,chinese,latin-1if has(“win32″)set fileencoding=chineseelseset fileencoding=utf-8endif“解决菜单乱码source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vim“解决consle输出乱码language messages zh_CN.utf-8,v
"detect current os,v
set nocompatible,v
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""",V
if(has("win32") || has("win95") || has("win64") || has("win16")) "??????????    let g:iswindows=1else    let g:iswindows=0endif,v
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Maintainer: "       Amir Salihefendic"       http://amix.dk - amix@amix.dk"" Version: "       5.0 - 29/05/12 15:43:36"" Blog_post: "       http://amix.dk/blog/post/19691#The-ultimate-Vim-configuration-on-Github"" Awesome_version:"       Get this config, nice color schemes and lots of plugins!""       Install the awesome version from:""           https://github.com/amix/vimrc"" Syntax_highlighted:"       http://amix.dk/vim/vimrc.html"" Raw_version: "       http://amix.dk/vim/vimrc.txt"" Sections:"    -> General"    -> VIM user interface"    -> Colors and Fonts"    -> Files and backups"    -> Text, tab and indent related"    -> Visual mode related"    -> Moving around, tabs and buffers"    -> Status line"    -> Editing mappings"    -> vimgrep searching and cope displaying"    -> Spell checking"    -> Misc"    -> Helper functions"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => General"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Sets how many lines of history VIM has to rememberset history=700" Enable filetype pluginsfiletype plugin onfiletype indent on" Set to auto read when a file is changed from the outsideset autoread" With a map leader it's possible to do extra key combinations" like <leader>w saves the current filelet mapleader = ","let g:mapleader = ","" Fast savingnmap <leader>w :w!<cr>"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => VIM user interface"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Set 7 lines to the cursor - when moving vertically using j/kset so=7" Turn on the WiLd menuset wildmenu" Ignore compiled filesset wildignore=*.o,*~,*.pycif has("win16") || has("win32")    set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Storeelse    set wildignore+=.git\*,.hg\*,.svn\*endif"Always show current positionset ruler" Height of the command barset cmdheight=2" A buffer becomes hidden when it is abandonedset hid" Configure backspace so it acts as it should actset backspace=eol,start,indentset whichwrap+=<,>,h,l" Ignore case when searchingset ignorecase" When searching try to be smart about cases set smartcase" Highlight search resultsset hlsearch" Makes search act like search in modern browsersset incsearch " Don't redraw while executing macros (good performance config)set lazyredraw " For regular expressions turn magic onset magic" Show matching brackets when text indicator is over themset showmatch " How many tenths of a second to blink when matching bracketsset mat=2" No annoying sound on errorsset noerrorbellsset novisualbellset t_vb=set tm=500" Add a bit extra margin to the leftset foldcolumn=1"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Colors and Fonts"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Enable syntax highlightingsyntax enable try    colorscheme desertcatchendtryset background=dark" Set extra options when running in GUI modeif has("gui_running")    set guioptions-=T    set guioptions-=e    set t_Co=256    set guitablabel=%M\ %tendif" Set utf8 as standard encoding and en_US as the standard languageset encoding=utf8" Use Unix as the standard file typeset ffs=unix,dos,mac"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Files, backups and undo"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Turn backup off, since most stuff is in SVN, git et.c anyway...set nobackupset nowbset noswapfile"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Text, tab and indent related"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Use spaces instead of tabsset expandtab" Be smart when using tabs ;)set smarttab" 1 tab == 4 spacesset shiftwidth=4set tabstop=4" Linebreak on 500 charactersset lbrset tw=500set ai "Auto indentset si "Smart indentset wrap "Wrap lines""""""""""""""""""""""""""""""" => Visual mode related""""""""""""""""""""""""""""""" Visual mode pressing * or # searches for the current selection" Super useful! From an idea by Michael Naumannvnoremap <silent> * :call VisualSelection('f', '')<CR>vnoremap <silent> # :call VisualSelection('b', '')<CR>"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Moving around, tabs, windows and buffers"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Treat long lines as break lines (useful when moving around in them)map j gjmap k gk" Map <Space> to / (search) and Ctrl-<Space> to ? (backwards search)map <space> /map <c-space> ?" Disable highlight when <leader><cr> is pressedmap <silent> <leader><cr> :noh<cr>" Smart way to move between windowsmap <C-j> <C-W>jmap <C-k> <C-W>kmap <C-h> <C-W>hmap <C-l> <C-W>l" Close the current buffermap <leader>bd :Bclose<cr>" Close all the buffersmap <leader>ba :1,1000 bd!<cr>" Useful mappings for managing tabsmap <leader>tn :tabnew<cr>map <leader>to :tabonly<cr>map <leader>tc :tabclose<cr>map <leader>tm :tabmove map <leader>t<leader> :tabnext " Opens a new tab with the current buffer's path" Super useful when editing files in the same directorymap <leader>te :tabedit <c-r>=expand("%:p:h")<cr>/" Switch CWD to the directory of the open buffermap <leader>cd :cd %:p:h<cr>:pwd<cr>" Specify the behavior when switching between buffers try  set switchbuf=useopen,usetab,newtab  set stal=2catchendtry" Return to last edit position when opening files (You want this!)autocmd BufReadPost *     \ if line("'\"") > 0 && line("'\"") <= line("$") |     \   exe "normal! g`\"" |     \ endif" Remember info about open buffers on closeset viminfo^=%""""""""""""""""""""""""""""""" => Status line""""""""""""""""""""""""""""""" Always show the status lineset laststatus=2" Format the status lineset statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Editing mappings"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Remap VIM 0 to first non-blank charactermap 0 ^" Move a line of text using ALT+[jk] or Comamnd+[jk] on macnmap <M-j> mz:m+<cr>`znmap <M-k> mz:m-2<cr>`zvmap <M-j> :m'>+<cr>`<my`>mzgv`yo`zvmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`zif has("mac") || has("macunix")  nmap <D-j> <M-j>  nmap <D-k> <M-k>  vmap <D-j> <M-j>  vmap <D-k> <M-k>endif" Delete trailing white space on save, useful for Python and CoffeeScript ;)func! DeleteTrailingWS()  exe "normal mz"  %s/\s\+$//ge  exe "normal `z"endfuncautocmd BufWrite *.py :call DeleteTrailingWS()autocmd BufWrite *.coffee :call DeleteTrailingWS()"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => vimgrep searching and cope displaying"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" When you press gv you vimgrep after the selected textvnoremap <silent> gv :call VisualSelection('gv', '')<CR>" Open vimgrep and put the cursor in the right positionmap <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>" Vimgreps in the current filemap <leader><space> :vimgrep // <C-R>%<C-A><right><right><right><right><right><right><right><right><right>" When you press <leader>r you can search and replace the selected textvnoremap <silent> <leader>r :call VisualSelection('replace', '')<CR>" Do :help cope if you are unsure what cope is. It's super useful!"" When you search with vimgrep, display your results in cope by doing:"   <leader>cc"" To go to the next search result do:"   <leader>n"" To go to the previous search results do:"   <leader>p"map <leader>cc :botright cope<cr>map <leader>co ggVGy:tabnew<cr>:set syntax=qf<cr>pggmap <leader>n :cn<cr>map <leader>p :cp<cr>"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Spell checking"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Pressing ,ss will toggle and untoggle spell checkingmap <leader>ss :setlocal spell!<cr>" Shortcuts using <leader>map <leader>sn ]smap <leader>sp [smap <leader>sa zgmap <leader>s? z="""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Misc"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Remove the Windows ^M - when the encodings gets messed upnoremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm" Quickly open a buffer for scripbblemap <leader>q :e ~/buffer<cr>" Toggle paste mode on and offmap <leader>pp :setlocal paste!<cr>"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Helper functions"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""function! CmdLine(str)    exe "menu Foo.Bar :" . a:str    emenu Foo.Bar    unmenu Fooendfunction function! VisualSelection(direction, extra_filter) range    let l:saved_reg = @"    execute "normal! vgvy"    let l:pattern = escape(@", '\\/.*$^~[]')    let l:pattern = substitute(l:pattern, "\n$", "", "")    if a:direction == 'b'        execute "normal ?" . l:pattern . "^M"    elseif a:direction == 'gv'        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.' . a:extra_filter)    elseif a:direction == 'replace'        call CmdLine("%s" . '/'. l:pattern . '/')    elseif a:direction == 'f'        execute "normal /" . l:pattern . "^M"    endif    let @/ = l:pattern    let @" = l:saved_regendfunction" Returns true if paste mode is enabledfunction! HasPaste()    if &paste        return 'PASTE MODE  '    en    return ''endfunction" Don't close window, when deleting a buffercommand! Bclose call <SID>BufcloseCloseIt()function! <SID>BufcloseCloseIt()   let l:currentBufNum = bufnr("%")   let l:alternateBufNum = bufnr("#")   if buflisted(l:alternateBufNum)     buffer #   else     bnext   endif   if bufnr("%") == l:currentBufNum     new   endif   if buflisted(l:currentBufNum)     execute("bdelete! ".l:currentBufNum)   endifendfunction,V
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Maintainer: "       Amir Salihefendic"       http://amix.dk - amix@amix.dk"" Version: "       5.0 - 29/05/12 15:43:36"" Blog_post: "       http://amix.dk/blog/post/19691#The-ultimate-Vim-configuration-on-Github"" Awesome_version:"       Get this config, nice color schemes and lots of plugins!""       Install the awesome version from:""           https://github.com/amix/vimrc"" Syntax_highlighted:"       http://amix.dk/vim/vimrc.html"" Raw_version: "       http://amix.dk/vim/vimrc.txt"" Sections:"    -> General"    -> VIM user interface"    -> Colors and Fonts"    -> Files and backups"    -> Text, tab and indent related"    -> Visual mode related"    -> Moving around, tabs and buffers"    -> Status line"    -> Editing mappings"    -> vimgrep searching and cope displaying"    -> Spell checking"    -> Misc"    -> Helper functions"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => General"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Sets how many lines of history VIM has to rememberset history=700" Enable filetype pluginsfiletype plugin onfiletype indent on" Set to auto read when a file is changed from the outsideset autoread" With a map leader it's possible to do extra key combinations" like <leader>w saves the current filelet mapleader = ","let g:mapleader = ","" Fast savingnmap <leader>w :w!<cr>"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => VIM user interface"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Set 7 lines to the cursor - when moving vertically using j/kset so=7" Turn on the WiLd menuset wildmenu" Ignore compiled filesset wildignore=*.o,*~,*.pycif has("win16") || has("win32")    set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Storeelse    set wildignore+=.git\*,.hg\*,.svn\*endif"Always show current positionset ruler" Height of the command barset cmdheight=2" A buffer becomes hidden when it is abandonedset hid" Configure backspace so it acts as it should actset backspace=eol,start,indentset whichwrap+=<,>,h,l" Ignore case when searchingset ignorecase" When searching try to be smart about cases set smartcase" Highlight search resultsset hlsearch" Makes search act like search in modern browsersset incsearch " Don't redraw while executing macros (good performance config)set lazyredraw " For regular expressions turn magic onset magic" Show matching brackets when text indicator is over themset showmatch " How many tenths of a second to blink when matching bracketsset mat=2" No annoying sound on errorsset noerrorbellsset novisualbellset t_vb=set tm=500" Add a bit extra margin to the leftset foldcolumn=1"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Colors and Fonts"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Enable syntax highlightingsyntax enable try    colorscheme desertcatchendtryset background=dark" Set extra options when running in GUI modeif has("gui_running")    set guioptions-=T    set guioptions-=e    set t_Co=256    set guitablabel=%M\ %tendif" Set utf8 as standard encoding and en_US as the standard languageset encoding=utf8" Use Unix as the standard file typeset ffs=unix,dos,mac"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Files, backups and undo"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Turn backup off, since most stuff is in SVN, git et.c anyway...set nobackupset nowbset noswapfile"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Text, tab and indent related"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Use spaces instead of tabsset expandtab" Be smart when using tabs ;)set smarttab" 1 tab == 4 spacesset shiftwidth=4set tabstop=4" Linebreak on 500 charactersset lbrset tw=500set ai "Auto indentset si "Smart indentset wrap "Wrap lines""""""""""""""""""""""""""""""" => Visual mode related""""""""""""""""""""""""""""""" Visual mode pressing * or # searches for the current selection" Super useful! From an idea by Michael Naumannvnoremap <silent> * :call VisualSelection('f', '')<CR>vnoremap <silent> # :call VisualSelection('b', '')<CR>"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Moving around, tabs, windows and buffers"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Treat long lines as break lines (useful when moving around in them)map j gjmap k gk" Map <Space> to / (search) and Ctrl-<Space> to ? (backwards search)map <space> /map <c-space> ?" Disable highlight when <leader><cr> is pressedmap <silent> <leader><cr> :noh<cr>" Smart way to move between windowsmap <C-j> <C-W>jmap <C-k> <C-W>kmap <C-h> <C-W>hmap <C-l> <C-W>l" Close the current buffermap <leader>bd :Bclose<cr>" Close all the buffersmap <leader>ba :1,1000 bd!<cr>" Useful mappings for managing tabsmap <leader>tn :tabnew<cr>map <leader>to :tabonly<cr>map <leader>tc :tabclose<cr>map <leader>tm :tabmove map <leader>t<leader> :tabnext " Opens a new tab with the current buffer's path" Super useful when editing files in the same directorymap <leader>te :tabedit <c-r>=expand("%:p:h")<cr>/" Switch CWD to the directory of the open buffermap <leader>cd :cd %:p:h<cr>:pwd<cr>" Specify the behavior when switching between buffers try  set switchbuf=useopen,usetab,newtab  set stal=2catchendtry" Return to last edit position when opening files (You want this!)autocmd BufReadPost *     \ if line("'\"") > 0 && line("'\"") <= line("$") |     \   exe "normal! g`\"" |     \ endif" Remember info about open buffers on closeset viminfo^=%""""""""""""""""""""""""""""""" => Status line""""""""""""""""""""""""""""""" Always show the status lineset laststatus=2" Format the status lineset statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Editing mappings"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Remap VIM 0 to first non-blank charactermap 0 ^" Move a line of text using ALT+[jk] or Comamnd+[jk] on macnmap <M-j> mz:m+<cr>`znmap <M-k> mz:m-2<cr>`zvmap <M-j> :m'>+<cr>`<my`>mzgv`yo`zvmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`zif has("mac") || has("macunix")  nmap <D-j> <M-j>  nmap <D-k> <M-k>  vmap <D-j> <M-j>  vmap <D-k> <M-k>endif" Delete trailing white space on save, useful for Python and CoffeeScript ;)func! DeleteTrailingWS()  exe "normal mz"  %s/\s\+$//ge  exe "normal `z"endfuncautocmd BufWrite *.py :call DeleteTrailingWS()autocmd BufWrite *.coffee :call DeleteTrailingWS()"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => vimgrep searching and cope displaying"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" When you press gv you vimgrep after the selected textvnoremap <silent> gv :call VisualSelection('gv', '')<CR>" Open vimgrep and put the cursor in the right positionmap <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>" Vimgreps in the current filemap <leader><space> :vimgrep // <C-R>%<C-A><right><right><right><right><right><right><right><right><right>" When you press <leader>r you can search and replace the selected textvnoremap <silent> <leader>r :call VisualSelection('replace', '')<CR>" Do :help cope if you are unsure what cope is. It's super useful!"" When you search with vimgrep, display your results in cope by doing:"   <leader>cc"" To go to the next search result do:"   <leader>n"" To go to the previous search results do:"   <leader>p"map <leader>cc :botright cope<cr>map <leader>co ggVGy:tabnew<cr>:set syntax=qf<cr>pggmap <leader>n :cn<cr>map <leader>p :cp<cr>"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Spell checking"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Pressing ,ss will toggle and untoggle spell checkingmap <leader>ss :setlocal spell!<cr>" Shortcuts using <leader>map <leader>sn ]smap <leader>sp [smap <leader>sa zgmap <leader>s? z="""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Misc"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Remove the Windows ^M - when the encodings gets messed upnoremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm" Quickly open a buffer for scripbblemap <leader>q :e ~/buffer<cr>" Toggle paste mode on and offmap <leader>pp :setlocal paste!<cr>"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" => Helper functions"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""function! CmdLine(str)    exe "menu Foo.Bar :" . a:str    emenu Foo.Bar    unmenu Fooendfunction function! VisualSelection(direction, extra_filter) range    let l:saved_reg = @"    execute "normal! vgvy"    let l:pattern = escape(@", '\\/.*$^~[]')    let l:pattern = substitute(l:pattern, "\n$", "", "")    if a:direction == 'b'        execute "normal ?" . l:pattern . "^M"    elseif a:direction == 'gv'        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.' . a:extra_filter)    elseif a:direction == 'replace'        call CmdLine("%s" . '/'. l:pattern . '/')    elseif a:direction == 'f'        execute "normal /" . l:pattern . "^M"    endif    let @/ = l:pattern    let @" = l:saved_regendfunction" Returns true if paste mode is enabledfunction! HasPaste()    if &paste        return 'PASTE MODE  '    en    return ''endfunction" Don't close window, when deleting a buffercommand! Bclose call <SID>BufcloseCloseIt()function! <SID>BufcloseCloseIt()   let l:currentBufNum = bufnr("%")   let l:alternateBufNum = bufnr("#")   if buflisted(l:alternateBufNum)     buffer #   else     bnext   endif   if bufnr("%") == l:currentBufNum     new   endif   if buflisted(l:currentBufNum)     execute("bdelete! ".l:currentBufNum)   endifendfunction,V
/home/jc46/gstreamer/OGG/05-Hollywood-16KHz-67.7kbps-mono.ogg,v
#include <gst/gst.h>#include <glib.h>static gbooleanbus_call (GstBus     *bus,          GstMessage *msg,          gpointer    data){  GMainLoop *loop = (GMainLoop *) data;  switch (GST_MESSAGE_TYPE (msg)) {    case GST_MESSAGE_EOS:      g_print ("End of stream\n");      g_main_loop_quit (loop);      break;    case GST_MESSAGE_ERROR: {      gchar  *debug;      GError *error;      gst_message_parse_error (msg, &error, &debug);      g_free (debug);      g_printerr ("Error: %s\n", error->message);      g_error_free (error);      g_main_loop_quit (loop);      break;    }    default:      break;  }  return TRUE;}static voidon_pad_added (GstElement *element,              GstPad     *pad,              gpointer    data){  GstPad *sinkpad;  GstElement *decoder = (GstElement *) data;  /* We can now link this pad with the vorbis-decoder sink pad */  g_print ("Dynamic pad created, linking demuxer/decoder\n");  sinkpad = gst_element_get_static_pad (decoder, "sink");  gst_pad_link (pad, sinkpad);  gst_object_unref (sinkpad);}intmain (int   argc,      char *argv[]){  GMainLoop *loop;  GstElement *pipeline, *source, *demuxer, *decoder, *conv, *sink;  GstBus *bus;  guint bus_watch_id;  /* Initialisation */  gst_init (&argc, &argv);  loop = g_main_loop_new (NULL, FALSE);  /* Check input arguments */  if (argc != 2) {    g_printerr ("Usage: %s <Ogg/Vorbis filename>\n", argv[0]);    return -1;  }  /* Create gstreamer elements */  pipeline = gst_pipeline_new ("audio-player");  source   = gst_element_factory_make ("filesrc",       "file-source");  demuxer  = gst_element_factory_make ("oggdemux",      "ogg-demuxer");  decoder  = gst_element_factory_make ("vorbisdec",     "vorbis-decoder");  conv     = gst_element_factory_make ("audioconvert",  "converter");  sink     = gst_element_factory_make ("autoaudiosink", "audio-output");  if (!pipeline || !source || !demuxer || !decoder || !conv || !sink) {    g_printerr ("One element could not be created. Exiting.\n");    return -1;  }  /* Set up the pipeline */  /* we set the input filename to the source element */  g_object_set (G_OBJECT (source), "location", argv[1], NULL);  /* we add a message handler */  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));  bus_watch_id = gst_bus_add_watch (bus, bus_call, loop);  gst_object_unref (bus);  /* we add all elements into the pipeline */  /* file-source | ogg-demuxer | vorbis-decoder | converter | alsa-output */  gst_bin_add_many (GST_BIN (pipeline),                    source, demuxer, decoder, conv, sink, NULL);  /* we link the elements together */  /* file-source -> ogg-demuxer ~> vorbis-decoder -> converter -> alsa-output */  gst_element_link (source, demuxer);  gst_element_link_many (decoder, conv, sink, NULL);  g_signal_connect (demuxer, "pad-added", G_CALLBACK (on_pad_added), decoder);  /* note that the demuxer will be linked to the decoder dynamically.     The reason is that Ogg may contain various streams (for example     audio and video). The source pad(s) will be created at run time,     by the demuxer when it detects the amount and nature of streams.     Therefore we connect a callback function which will be executed     when the "pad-added" is emitted.*/  /* Set the pipeline to "playing" state*/  g_print ("Now playing: %s\n", argv[1]);  gst_element_set_state (pipeline, GST_STATE_PLAYING);  /* Iterate */  g_print ("Running...\n");  g_main_loop_run (loop);  /* Out of the main loop, clean up nicely */  g_print ("Returned, stopping playback\n");  gst_element_set_state (pipeline, GST_STATE_NULL);  g_print ("Deleting pipeline\n");  gst_object_unref (GST_OBJECT (pipeline));  g_source_remove (bus_watch_id);  g_main_loop_unref (loop);  return 0;},v
l,v
.vim_runtime,v
